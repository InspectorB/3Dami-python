#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class NoData:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoData')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SessionStart:
  """
  Attributes:
   - properties
   - blenderVersion
   - blenderSubversion
   - os
   - osVersion
   - resolutionX
   - resolutionY
   - gui
   - numDisplays
   - sessionKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.I16, 'blenderVersion', None, None, ), # 2
    (3, TType.I16, 'blenderSubversion', None, None, ), # 3
    (4, TType.STRING, 'os', None, None, ), # 4
    (5, TType.STRING, 'osVersion', None, None, ), # 5
    (6, TType.I16, 'resolutionX', None, None, ), # 6
    (7, TType.I16, 'resolutionY', None, None, ), # 7
    (8, TType.BOOL, 'gui', None, None, ), # 8
    (9, TType.I16, 'numDisplays', None, None, ), # 9
    (10, TType.STRING, 'sessionKey', None, None, ), # 10
  )

  def __init__(self, properties=None, blenderVersion=None, blenderSubversion=None, os=None, osVersion=None, resolutionX=None, resolutionY=None, gui=None, numDisplays=None, sessionKey=None,):
    self.properties = properties
    self.blenderVersion = blenderVersion
    self.blenderSubversion = blenderSubversion
    self.os = os
    self.osVersion = osVersion
    self.resolutionX = resolutionX
    self.resolutionY = resolutionY
    self.gui = gui
    self.numDisplays = numDisplays
    self.sessionKey = sessionKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.properties = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString();
            _val6 = iprot.readString();
            self.properties[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.blenderVersion = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.blenderSubversion = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.os = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.osVersion = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I16:
          self.resolutionX = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.resolutionY = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.gui = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I16:
          self.numDisplays = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.sessionKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SessionStart')
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
      for kiter7,viter8 in self.properties.items():
        oprot.writeString(kiter7)
        oprot.writeString(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.blenderVersion is not None:
      oprot.writeFieldBegin('blenderVersion', TType.I16, 2)
      oprot.writeI16(self.blenderVersion)
      oprot.writeFieldEnd()
    if self.blenderSubversion is not None:
      oprot.writeFieldBegin('blenderSubversion', TType.I16, 3)
      oprot.writeI16(self.blenderSubversion)
      oprot.writeFieldEnd()
    if self.os is not None:
      oprot.writeFieldBegin('os', TType.STRING, 4)
      oprot.writeString(self.os)
      oprot.writeFieldEnd()
    if self.osVersion is not None:
      oprot.writeFieldBegin('osVersion', TType.STRING, 5)
      oprot.writeString(self.osVersion)
      oprot.writeFieldEnd()
    if self.resolutionX is not None:
      oprot.writeFieldBegin('resolutionX', TType.I16, 6)
      oprot.writeI16(self.resolutionX)
      oprot.writeFieldEnd()
    if self.resolutionY is not None:
      oprot.writeFieldBegin('resolutionY', TType.I16, 7)
      oprot.writeI16(self.resolutionY)
      oprot.writeFieldEnd()
    if self.gui is not None:
      oprot.writeFieldBegin('gui', TType.BOOL, 8)
      oprot.writeBool(self.gui)
      oprot.writeFieldEnd()
    if self.numDisplays is not None:
      oprot.writeFieldBegin('numDisplays', TType.I16, 9)
      oprot.writeI16(self.numDisplays)
      oprot.writeFieldEnd()
    if self.sessionKey is not None:
      oprot.writeFieldBegin('sessionKey', TType.STRING, 10)
      oprot.writeString(self.sessionKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SessionEnd:
  """
  Attributes:
   - sessionKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sessionKey', None, None, ), # 1
  )

  def __init__(self, sessionKey=None,):
    self.sessionKey = sessionKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sessionKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SessionEnd')
    if self.sessionKey is not None:
      oprot.writeFieldBegin('sessionKey', TType.STRING, 1)
      oprot.writeString(self.sessionKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RNAPropertyData:
  """
  Attributes:
   - valueBoolean
   - listBoolean
   - valueInt
   - listInt
   - valueDouble
   - listDouble
   - valueString
   - valueEnum
   - listEnum
   - valuePointer
   - collection
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'valueBoolean', None, None, ), # 1
    (2, TType.LIST, 'listBoolean', (TType.BOOL,None), None, ), # 2
    (3, TType.I32, 'valueInt', None, None, ), # 3
    (4, TType.LIST, 'listInt', (TType.I32,None), None, ), # 4
    (5, TType.DOUBLE, 'valueDouble', None, None, ), # 5
    (6, TType.LIST, 'listDouble', (TType.DOUBLE,None), None, ), # 6
    (7, TType.STRING, 'valueString', None, None, ), # 7
    (8, TType.STRING, 'valueEnum', None, None, ), # 8
    (9, TType.SET, 'listEnum', (TType.STRING,None), None, ), # 9
    (10, TType.STRING, 'valuePointer', None, None, ), # 10
    (11, TType.LIST, 'collection', (TType.STRING,None), None, ), # 11
  )

  def __init__(self, valueBoolean=None, listBoolean=None, valueInt=None, listInt=None, valueDouble=None, listDouble=None, valueString=None, valueEnum=None, listEnum=None, valuePointer=None, collection=None,):
    self.valueBoolean = valueBoolean
    self.listBoolean = listBoolean
    self.valueInt = valueInt
    self.listInt = listInt
    self.valueDouble = valueDouble
    self.listDouble = listDouble
    self.valueString = valueString
    self.valueEnum = valueEnum
    self.listEnum = listEnum
    self.valuePointer = valuePointer
    self.collection = collection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.valueBoolean = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.listBoolean = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in xrange(_size9):
            _elem14 = iprot.readBool();
            self.listBoolean.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.valueInt = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.listInt = []
          (_etype18, _size15) = iprot.readListBegin()
          for _i19 in xrange(_size15):
            _elem20 = iprot.readI32();
            self.listInt.append(_elem20)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.valueDouble = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.listDouble = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readDouble();
            self.listDouble.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.valueString = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.valueEnum = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.SET:
          self.listEnum = set()
          (_etype30, _size27) = iprot.readSetBegin()
          for _i31 in xrange(_size27):
            _elem32 = iprot.readString();
            self.listEnum.add(_elem32)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.valuePointer = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.collection = []
          (_etype36, _size33) = iprot.readListBegin()
          for _i37 in xrange(_size33):
            _elem38 = iprot.readString();
            self.collection.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RNAPropertyData')
    if self.valueBoolean is not None:
      oprot.writeFieldBegin('valueBoolean', TType.BOOL, 1)
      oprot.writeBool(self.valueBoolean)
      oprot.writeFieldEnd()
    if self.listBoolean is not None:
      oprot.writeFieldBegin('listBoolean', TType.LIST, 2)
      oprot.writeListBegin(TType.BOOL, len(self.listBoolean))
      for iter39 in self.listBoolean:
        oprot.writeBool(iter39)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.valueInt is not None:
      oprot.writeFieldBegin('valueInt', TType.I32, 3)
      oprot.writeI32(self.valueInt)
      oprot.writeFieldEnd()
    if self.listInt is not None:
      oprot.writeFieldBegin('listInt', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.listInt))
      for iter40 in self.listInt:
        oprot.writeI32(iter40)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.valueDouble is not None:
      oprot.writeFieldBegin('valueDouble', TType.DOUBLE, 5)
      oprot.writeDouble(self.valueDouble)
      oprot.writeFieldEnd()
    if self.listDouble is not None:
      oprot.writeFieldBegin('listDouble', TType.LIST, 6)
      oprot.writeListBegin(TType.DOUBLE, len(self.listDouble))
      for iter41 in self.listDouble:
        oprot.writeDouble(iter41)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.valueString is not None:
      oprot.writeFieldBegin('valueString', TType.STRING, 7)
      oprot.writeString(self.valueString)
      oprot.writeFieldEnd()
    if self.valueEnum is not None:
      oprot.writeFieldBegin('valueEnum', TType.STRING, 8)
      oprot.writeString(self.valueEnum)
      oprot.writeFieldEnd()
    if self.listEnum is not None:
      oprot.writeFieldBegin('listEnum', TType.SET, 9)
      oprot.writeSetBegin(TType.STRING, len(self.listEnum))
      for iter42 in self.listEnum:
        oprot.writeString(iter42)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.valuePointer is not None:
      oprot.writeFieldBegin('valuePointer', TType.STRING, 10)
      oprot.writeString(self.valuePointer)
      oprot.writeFieldEnd()
    if self.collection is not None:
      oprot.writeFieldBegin('collection', TType.LIST, 11)
      oprot.writeListBegin(TType.STRING, len(self.collection))
      for iter43 in self.collection:
        oprot.writeString(iter43)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RNAProperty:
  """
  * `type` is set to -1 for unknown types
  * `length` is set to -1 for unknown values where the type is known
  *

  type:

  PROP_BOOLEAN      = 0,
  PROP_INT          = 1,
  PROP_FLOAT        = 2,
  PROP_STRING       = 3,
  PROP_ENUM         = 4,
  PROP_POINTER      = 5,
  PROP_COLLECTION   = 6,

  subtype:

  PROP_NONE              = 0,

  PROP_FILEPATH          = 1,
  PROP_DIRPATH           = 2,
  PROP_FILENAME          = 3,
  PROP_BYTESTRING        = 4,
  PROP_PASSWORD          = 6,

  PROP_PIXEL             = 12,
  PROP_UNSIGNED          = 13,
  PROP_PERCENTAGE        = 14,
  PROP_FACTOR            = 15,
  PROP_ANGLE             = 16 | PROP_UNIT_ROTATION,
  PROP_TIME              = 17 | PROP_UNIT_TIME,
  PROP_DISTANCE          = 18 | PROP_UNIT_LENGTH,
  PROP_DISTANCE_CAMERA   = 19 | PROP_UNIT_CAMERA,

  PROP_COLOR             = 20,
  PROP_TRANSLATION       = 21 | PROP_UNIT_LENGTH,
  PROP_DIRECTION         = 22,
  PROP_VELOCITY          = 23 | PROP_UNIT_VELOCITY,
  PROP_ACCELERATION      = 24 | PROP_UNIT_ACCELERATION,
  PROP_MATRIX            = 25,
  PROP_EULER             = 26 | PROP_UNIT_ROTATION,
  PROP_QUATERNION        = 27,
  PROP_AXISANGLE         = 28,
  PROP_XYZ               = 29,
  PROP_XYZ_LENGTH        = 29 | PROP_UNIT_LENGTH,
  PROP_COLOR_GAMMA       = 30,
  PROP_COORDS            = 31,

  PROP_LAYER             = 40,
  PROP_LAYER_MEMBER      = 41,
  *

  Attributes:
   - identifier
   - type
   - subtype
   - length
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'identifier', None, None, ), # 1
    (2, TType.I16, 'type', None, None, ), # 2
    (3, TType.I16, 'length', None, None, ), # 3
    (4, TType.STRUCT, 'data', (RNAPropertyData, RNAPropertyData.thrift_spec), None, ), # 4
    (5, TType.I16, 'subtype', None, None, ), # 5
  )

  def __init__(self, identifier=None, type=None, subtype=None, length=None, data=None,):
    self.identifier = identifier
    self.type = type
    self.subtype = subtype
    self.length = length
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.identifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.type = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.subtype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.length = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.data = RNAPropertyData()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RNAProperty')
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.STRING, 1)
      oprot.writeString(self.identifier)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I16, 2)
      oprot.writeI16(self.type)
      oprot.writeFieldEnd()
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I16, 3)
      oprot.writeI16(self.length)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRUCT, 4)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    if self.subtype is not None:
      oprot.writeFieldBegin('subtype', TType.I16, 5)
      oprot.writeI16(self.subtype)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Object:
  """
  Attributes:
   - selected
   - active
   - name
   - type
   - baseAddress
   - objectAddress
   - parentType
   - parentAddress
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'selected', None, None, ), # 1
    (2, TType.BOOL, 'active', None, None, ), # 2
    (3, TType.STRING, 'name', None, None, ), # 3
    (4, TType.I16, 'type', None, None, ), # 4
    (5, TType.STRING, 'baseAddress', None, None, ), # 5
    (6, TType.STRING, 'objectAddress', None, None, ), # 6
    (7, TType.I16, 'parentType', None, None, ), # 7
    (8, TType.STRING, 'parentAddress', None, None, ), # 8
  )

  def __init__(self, selected=None, active=None, name=None, type=None, baseAddress=None, objectAddress=None, parentType=None, parentAddress=None,):
    self.selected = selected
    self.active = active
    self.name = name
    self.type = type
    self.baseAddress = baseAddress
    self.objectAddress = objectAddress
    self.parentType = parentType
    self.parentAddress = parentAddress

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.selected = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.active = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.type = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.baseAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.objectAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.parentType = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.parentAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Object')
    if self.selected is not None:
      oprot.writeFieldBegin('selected', TType.BOOL, 1)
      oprot.writeBool(self.selected)
      oprot.writeFieldEnd()
    if self.active is not None:
      oprot.writeFieldBegin('active', TType.BOOL, 2)
      oprot.writeBool(self.active)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I16, 4)
      oprot.writeI16(self.type)
      oprot.writeFieldEnd()
    if self.baseAddress is not None:
      oprot.writeFieldBegin('baseAddress', TType.STRING, 5)
      oprot.writeString(self.baseAddress)
      oprot.writeFieldEnd()
    if self.objectAddress is not None:
      oprot.writeFieldBegin('objectAddress', TType.STRING, 6)
      oprot.writeString(self.objectAddress)
      oprot.writeFieldEnd()
    if self.parentType is not None:
      oprot.writeFieldBegin('parentType', TType.I16, 7)
      oprot.writeI16(self.parentType)
      oprot.writeFieldEnd()
    if self.parentAddress is not None:
      oprot.writeFieldBegin('parentAddress', TType.STRING, 8)
      oprot.writeString(self.parentAddress)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ViewOrientation:
  """
  Attributes:
   - offset
   - distance
   - viewquat
   - camzoom
   - camdx
   - camdy
   - is_persp
   - persp
   - view
   - is_local
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'offset', (TType.DOUBLE,None), None, ), # 1
    (2, TType.DOUBLE, 'distance', None, None, ), # 2
    (3, TType.LIST, 'viewquat', (TType.DOUBLE,None), None, ), # 3
    (4, TType.DOUBLE, 'camzoom', None, None, ), # 4
    (5, TType.DOUBLE, 'camdx', None, None, ), # 5
    (6, TType.DOUBLE, 'camdy', None, None, ), # 6
    (7, TType.BOOL, 'is_persp', None, None, ), # 7
    (8, TType.BYTE, 'persp', None, None, ), # 8
    (9, TType.BYTE, 'view', None, None, ), # 9
    (10, TType.BOOL, 'is_local', None, None, ), # 10
  )

  def __init__(self, offset=None, distance=None, viewquat=None, camzoom=None, camdx=None, camdy=None, is_persp=None, persp=None, view=None, is_local=None,):
    self.offset = offset
    self.distance = distance
    self.viewquat = viewquat
    self.camzoom = camzoom
    self.camdx = camdx
    self.camdy = camdy
    self.is_persp = is_persp
    self.persp = persp
    self.view = view
    self.is_local = is_local

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.offset = []
          (_etype47, _size44) = iprot.readListBegin()
          for _i48 in xrange(_size44):
            _elem49 = iprot.readDouble();
            self.offset.append(_elem49)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.distance = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.viewquat = []
          (_etype53, _size50) = iprot.readListBegin()
          for _i54 in xrange(_size50):
            _elem55 = iprot.readDouble();
            self.viewquat.append(_elem55)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.camzoom = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.camdx = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.camdy = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.is_persp = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.persp = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.view = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.is_local = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ViewOrientation')
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.LIST, 1)
      oprot.writeListBegin(TType.DOUBLE, len(self.offset))
      for iter56 in self.offset:
        oprot.writeDouble(iter56)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.distance is not None:
      oprot.writeFieldBegin('distance', TType.DOUBLE, 2)
      oprot.writeDouble(self.distance)
      oprot.writeFieldEnd()
    if self.viewquat is not None:
      oprot.writeFieldBegin('viewquat', TType.LIST, 3)
      oprot.writeListBegin(TType.DOUBLE, len(self.viewquat))
      for iter57 in self.viewquat:
        oprot.writeDouble(iter57)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.camzoom is not None:
      oprot.writeFieldBegin('camzoom', TType.DOUBLE, 4)
      oprot.writeDouble(self.camzoom)
      oprot.writeFieldEnd()
    if self.camdx is not None:
      oprot.writeFieldBegin('camdx', TType.DOUBLE, 5)
      oprot.writeDouble(self.camdx)
      oprot.writeFieldEnd()
    if self.camdy is not None:
      oprot.writeFieldBegin('camdy', TType.DOUBLE, 6)
      oprot.writeDouble(self.camdy)
      oprot.writeFieldEnd()
    if self.is_persp is not None:
      oprot.writeFieldBegin('is_persp', TType.BOOL, 7)
      oprot.writeBool(self.is_persp)
      oprot.writeFieldEnd()
    if self.persp is not None:
      oprot.writeFieldBegin('persp', TType.BYTE, 8)
      oprot.writeByte(self.persp)
      oprot.writeFieldEnd()
    if self.view is not None:
      oprot.writeFieldBegin('view', TType.BYTE, 9)
      oprot.writeByte(self.view)
      oprot.writeFieldEnd()
    if self.is_local is not None:
      oprot.writeFieldBegin('is_local', TType.BOOL, 10)
      oprot.writeBool(self.is_local)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Context:
  """
  Attributes:
   - windowName
   - windowAddress
   - screenName
   - screenAddress
   - spaceType
   - spaceAddress
   - regionType
   - regionAddress
   - dataMode
   - sceneName
   - sceneAddress
   - viewOrientation
   - visibleObjects
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'windowName', None, None, ), # 1
    (2, TType.STRING, 'windowAddress', None, None, ), # 2
    (3, TType.STRING, 'screenName', None, None, ), # 3
    (4, TType.STRING, 'screenAddress', None, None, ), # 4
    (5, TType.I16, 'spaceType', None, None, ), # 5
    (6, TType.STRING, 'spaceAddress', None, None, ), # 6
    (7, TType.I16, 'regionType', None, None, ), # 7
    (8, TType.STRING, 'regionAddress', None, None, ), # 8
    (9, TType.STRING, 'dataMode', None, None, ), # 9
    (10, TType.STRING, 'sceneName', None, None, ), # 10
    (11, TType.STRING, 'sceneAddress', None, None, ), # 11
    None, # 12
    None, # 13
    None, # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    None, # 20
    None, # 21
    None, # 22
    None, # 23
    None, # 24
    None, # 25
    None, # 26
    None, # 27
    None, # 28
    None, # 29
    None, # 30
    None, # 31
    None, # 32
    None, # 33
    None, # 34
    None, # 35
    None, # 36
    None, # 37
    None, # 38
    None, # 39
    (40, TType.STRUCT, 'viewOrientation', (ViewOrientation, ViewOrientation.thrift_spec), None, ), # 40
    None, # 41
    None, # 42
    None, # 43
    None, # 44
    None, # 45
    None, # 46
    None, # 47
    None, # 48
    None, # 49
    (50, TType.LIST, 'visibleObjects', (TType.STRUCT,(Object, Object.thrift_spec)), None, ), # 50
  )

  def __init__(self, windowName=None, windowAddress=None, screenName=None, screenAddress=None, spaceType=None, spaceAddress=None, regionType=None, regionAddress=None, dataMode=None, sceneName=None, sceneAddress=None, viewOrientation=None, visibleObjects=None,):
    self.windowName = windowName
    self.windowAddress = windowAddress
    self.screenName = screenName
    self.screenAddress = screenAddress
    self.spaceType = spaceType
    self.spaceAddress = spaceAddress
    self.regionType = regionType
    self.regionAddress = regionAddress
    self.dataMode = dataMode
    self.sceneName = sceneName
    self.sceneAddress = sceneAddress
    self.viewOrientation = viewOrientation
    self.visibleObjects = visibleObjects

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.windowName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.windowAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.screenName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.screenAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.spaceType = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.spaceAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.regionType = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.regionAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.dataMode = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.sceneName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.sceneAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 40:
        if ftype == TType.STRUCT:
          self.viewOrientation = ViewOrientation()
          self.viewOrientation.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 50:
        if ftype == TType.LIST:
          self.visibleObjects = []
          (_etype61, _size58) = iprot.readListBegin()
          for _i62 in xrange(_size58):
            _elem63 = Object()
            _elem63.read(iprot)
            self.visibleObjects.append(_elem63)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Context')
    if self.windowName is not None:
      oprot.writeFieldBegin('windowName', TType.STRING, 1)
      oprot.writeString(self.windowName)
      oprot.writeFieldEnd()
    if self.windowAddress is not None:
      oprot.writeFieldBegin('windowAddress', TType.STRING, 2)
      oprot.writeString(self.windowAddress)
      oprot.writeFieldEnd()
    if self.screenName is not None:
      oprot.writeFieldBegin('screenName', TType.STRING, 3)
      oprot.writeString(self.screenName)
      oprot.writeFieldEnd()
    if self.screenAddress is not None:
      oprot.writeFieldBegin('screenAddress', TType.STRING, 4)
      oprot.writeString(self.screenAddress)
      oprot.writeFieldEnd()
    if self.spaceType is not None:
      oprot.writeFieldBegin('spaceType', TType.I16, 5)
      oprot.writeI16(self.spaceType)
      oprot.writeFieldEnd()
    if self.spaceAddress is not None:
      oprot.writeFieldBegin('spaceAddress', TType.STRING, 6)
      oprot.writeString(self.spaceAddress)
      oprot.writeFieldEnd()
    if self.regionType is not None:
      oprot.writeFieldBegin('regionType', TType.I16, 7)
      oprot.writeI16(self.regionType)
      oprot.writeFieldEnd()
    if self.regionAddress is not None:
      oprot.writeFieldBegin('regionAddress', TType.STRING, 8)
      oprot.writeString(self.regionAddress)
      oprot.writeFieldEnd()
    if self.dataMode is not None:
      oprot.writeFieldBegin('dataMode', TType.STRING, 9)
      oprot.writeString(self.dataMode)
      oprot.writeFieldEnd()
    if self.sceneName is not None:
      oprot.writeFieldBegin('sceneName', TType.STRING, 10)
      oprot.writeString(self.sceneName)
      oprot.writeFieldEnd()
    if self.sceneAddress is not None:
      oprot.writeFieldBegin('sceneAddress', TType.STRING, 11)
      oprot.writeString(self.sceneAddress)
      oprot.writeFieldEnd()
    if self.viewOrientation is not None:
      oprot.writeFieldBegin('viewOrientation', TType.STRUCT, 40)
      self.viewOrientation.write(oprot)
      oprot.writeFieldEnd()
    if self.visibleObjects is not None:
      oprot.writeFieldBegin('visibleObjects', TType.LIST, 50)
      oprot.writeListBegin(TType.STRUCT, len(self.visibleObjects))
      for iter64 in self.visibleObjects:
        iter64.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Report:
  """
  Attributes:
   - type
   - flag
   - typestr
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'type', None, None, ), # 1
    (2, TType.I32, 'flag', None, None, ), # 2
    (3, TType.STRING, 'typestr', None, None, ), # 3
    (4, TType.STRING, 'message', None, None, ), # 4
  )

  def __init__(self, type=None, flag=None, typestr=None, message=None,):
    self.type = type
    self.flag = flag
    self.typestr = typestr
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.type = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.flag = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.typestr = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Report')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I16, 1)
      oprot.writeI16(self.type)
      oprot.writeFieldEnd()
    if self.flag is not None:
      oprot.writeFieldBegin('flag', TType.I32, 2)
      oprot.writeI32(self.flag)
      oprot.writeFieldEnd()
    if self.typestr is not None:
      oprot.writeFieldBegin('typestr', TType.STRING, 3)
      oprot.writeString(self.typestr)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 4)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WmOp:
  """
  Attributes:
   - operatorId
   - properties
   - pythonRepresentation
   - screenshotHash
   - context
   - repeat
   - retval
   - reports
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'operatorId', None, None, ), # 1
    (2, TType.LIST, 'properties', (TType.STRUCT,(RNAProperty, RNAProperty.thrift_spec)), None, ), # 2
    (3, TType.STRING, 'pythonRepresentation', None, None, ), # 3
    (4, TType.STRING, 'screenshotHash', None, None, ), # 4
    (5, TType.STRUCT, 'context', (Context, Context.thrift_spec), None, ), # 5
    (6, TType.BOOL, 'repeat', None, None, ), # 6
    (7, TType.I32, 'retval', None, None, ), # 7
    (8, TType.LIST, 'reports', (TType.STRUCT,(Report, Report.thrift_spec)), None, ), # 8
  )

  def __init__(self, operatorId=None, properties=None, pythonRepresentation=None, screenshotHash=None, context=None, repeat=None, retval=None, reports=None,):
    self.operatorId = operatorId
    self.properties = properties
    self.pythonRepresentation = pythonRepresentation
    self.screenshotHash = screenshotHash
    self.context = context
    self.repeat = repeat
    self.retval = retval
    self.reports = reports

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.operatorId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.properties = []
          (_etype68, _size65) = iprot.readListBegin()
          for _i69 in xrange(_size65):
            _elem70 = RNAProperty()
            _elem70.read(iprot)
            self.properties.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pythonRepresentation = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.screenshotHash = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.context = Context()
          self.context.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.repeat = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.retval = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.reports = []
          (_etype74, _size71) = iprot.readListBegin()
          for _i75 in xrange(_size71):
            _elem76 = Report()
            _elem76.read(iprot)
            self.reports.append(_elem76)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WmOp')
    if self.operatorId is not None:
      oprot.writeFieldBegin('operatorId', TType.STRING, 1)
      oprot.writeString(self.operatorId)
      oprot.writeFieldEnd()
    if self.properties is not None:
      oprot.writeFieldBegin('properties', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.properties))
      for iter77 in self.properties:
        iter77.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.pythonRepresentation is not None:
      oprot.writeFieldBegin('pythonRepresentation', TType.STRING, 3)
      oprot.writeString(self.pythonRepresentation)
      oprot.writeFieldEnd()
    if self.screenshotHash is not None:
      oprot.writeFieldBegin('screenshotHash', TType.STRING, 4)
      oprot.writeString(self.screenshotHash)
      oprot.writeFieldEnd()
    if self.context is not None:
      oprot.writeFieldBegin('context', TType.STRUCT, 5)
      self.context.write(oprot)
      oprot.writeFieldEnd()
    if self.repeat is not None:
      oprot.writeFieldBegin('repeat', TType.BOOL, 6)
      oprot.writeBool(self.repeat)
      oprot.writeFieldEnd()
    if self.retval is not None:
      oprot.writeFieldBegin('retval', TType.I32, 7)
      oprot.writeI32(self.retval)
      oprot.writeFieldEnd()
    if self.reports is not None:
      oprot.writeFieldBegin('reports', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.reports))
      for iter78 in self.reports:
        iter78.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WmTabletData:
  """
  Attributes:
   - active
   - pressure
   - xtilt
   - ytilt
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'active', None, None, ), # 1
    (2, TType.DOUBLE, 'pressure', None, None, ), # 2
    (3, TType.DOUBLE, 'xtilt', None, None, ), # 3
    (4, TType.DOUBLE, 'ytilt', None, None, ), # 4
  )

  def __init__(self, active=None, pressure=None, xtilt=None, ytilt=None,):
    self.active = active
    self.pressure = pressure
    self.xtilt = xtilt
    self.ytilt = ytilt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.active = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.pressure = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.xtilt = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.ytilt = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WmTabletData')
    if self.active is not None:
      oprot.writeFieldBegin('active', TType.I32, 1)
      oprot.writeI32(self.active)
      oprot.writeFieldEnd()
    if self.pressure is not None:
      oprot.writeFieldBegin('pressure', TType.DOUBLE, 2)
      oprot.writeDouble(self.pressure)
      oprot.writeFieldEnd()
    if self.xtilt is not None:
      oprot.writeFieldBegin('xtilt', TType.DOUBLE, 3)
      oprot.writeDouble(self.xtilt)
      oprot.writeFieldEnd()
    if self.ytilt is not None:
      oprot.writeFieldBegin('ytilt', TType.DOUBLE, 4)
      oprot.writeDouble(self.ytilt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WmEv:
  """
  Attributes:
   - type
   - value
   - x
   - y
   - mval1
   - mval2
   - character
   - prevtype
   - prevval
   - prevx
   - prevy
   - prevclicktime
   - prevclickx
   - prevclicky
   - shift
   - ctrl
   - alt
   - oskey
   - keymodifier
   - check_click
   - keymap_idname
   - tablet_data
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'type', None, None, ), # 1
    (2, TType.I16, 'value', None, None, ), # 2
    (3, TType.I32, 'x', None, None, ), # 3
    (4, TType.I32, 'y', None, None, ), # 4
    (5, TType.I32, 'mval1', None, None, ), # 5
    (6, TType.I32, 'mval2', None, None, ), # 6
    (7, TType.STRING, 'character', None, None, ), # 7
    (8, TType.I16, 'prevtype', None, None, ), # 8
    (9, TType.I16, 'prevval', None, None, ), # 9
    (10, TType.I32, 'prevx', None, None, ), # 10
    (11, TType.I32, 'prevy', None, None, ), # 11
    (12, TType.DOUBLE, 'prevclicktime', None, None, ), # 12
    (13, TType.I32, 'prevclickx', None, None, ), # 13
    (14, TType.I32, 'prevclicky', None, None, ), # 14
    (15, TType.I16, 'shift', None, None, ), # 15
    (16, TType.I16, 'ctrl', None, None, ), # 16
    (17, TType.I16, 'alt', None, None, ), # 17
    (18, TType.I16, 'oskey', None, None, ), # 18
    (19, TType.I16, 'keymodifier', None, None, ), # 19
    (20, TType.I16, 'check_click', None, None, ), # 20
    (21, TType.STRING, 'keymap_idname', None, None, ), # 21
    (22, TType.STRUCT, 'tablet_data', (WmTabletData, WmTabletData.thrift_spec), None, ), # 22
  )

  def __init__(self, type=None, value=None, x=None, y=None, mval1=None, mval2=None, character=None, prevtype=None, prevval=None, prevx=None, prevy=None, prevclicktime=None, prevclickx=None, prevclicky=None, shift=None, ctrl=None, alt=None, oskey=None, keymodifier=None, check_click=None, keymap_idname=None, tablet_data=None,):
    self.type = type
    self.value = value
    self.x = x
    self.y = y
    self.mval1 = mval1
    self.mval2 = mval2
    self.character = character
    self.prevtype = prevtype
    self.prevval = prevval
    self.prevx = prevx
    self.prevy = prevy
    self.prevclicktime = prevclicktime
    self.prevclickx = prevclickx
    self.prevclicky = prevclicky
    self.shift = shift
    self.ctrl = ctrl
    self.alt = alt
    self.oskey = oskey
    self.keymodifier = keymodifier
    self.check_click = check_click
    self.keymap_idname = keymap_idname
    self.tablet_data = tablet_data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.type = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.value = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.x = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.y = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.mval1 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.mval2 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.character = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I16:
          self.prevtype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I16:
          self.prevval = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.prevx = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.prevy = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.DOUBLE:
          self.prevclicktime = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.prevclickx = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.prevclicky = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I16:
          self.shift = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I16:
          self.ctrl = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I16:
          self.alt = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I16:
          self.oskey = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.I16:
          self.keymodifier = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.I16:
          self.check_click = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRING:
          self.keymap_idname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRUCT:
          self.tablet_data = WmTabletData()
          self.tablet_data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WmEv')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I16, 1)
      oprot.writeI16(self.type)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I16, 2)
      oprot.writeI16(self.value)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.I32, 3)
      oprot.writeI32(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.I32, 4)
      oprot.writeI32(self.y)
      oprot.writeFieldEnd()
    if self.mval1 is not None:
      oprot.writeFieldBegin('mval1', TType.I32, 5)
      oprot.writeI32(self.mval1)
      oprot.writeFieldEnd()
    if self.mval2 is not None:
      oprot.writeFieldBegin('mval2', TType.I32, 6)
      oprot.writeI32(self.mval2)
      oprot.writeFieldEnd()
    if self.character is not None:
      oprot.writeFieldBegin('character', TType.STRING, 7)
      oprot.writeString(self.character)
      oprot.writeFieldEnd()
    if self.prevtype is not None:
      oprot.writeFieldBegin('prevtype', TType.I16, 8)
      oprot.writeI16(self.prevtype)
      oprot.writeFieldEnd()
    if self.prevval is not None:
      oprot.writeFieldBegin('prevval', TType.I16, 9)
      oprot.writeI16(self.prevval)
      oprot.writeFieldEnd()
    if self.prevx is not None:
      oprot.writeFieldBegin('prevx', TType.I32, 10)
      oprot.writeI32(self.prevx)
      oprot.writeFieldEnd()
    if self.prevy is not None:
      oprot.writeFieldBegin('prevy', TType.I32, 11)
      oprot.writeI32(self.prevy)
      oprot.writeFieldEnd()
    if self.prevclicktime is not None:
      oprot.writeFieldBegin('prevclicktime', TType.DOUBLE, 12)
      oprot.writeDouble(self.prevclicktime)
      oprot.writeFieldEnd()
    if self.prevclickx is not None:
      oprot.writeFieldBegin('prevclickx', TType.I32, 13)
      oprot.writeI32(self.prevclickx)
      oprot.writeFieldEnd()
    if self.prevclicky is not None:
      oprot.writeFieldBegin('prevclicky', TType.I32, 14)
      oprot.writeI32(self.prevclicky)
      oprot.writeFieldEnd()
    if self.shift is not None:
      oprot.writeFieldBegin('shift', TType.I16, 15)
      oprot.writeI16(self.shift)
      oprot.writeFieldEnd()
    if self.ctrl is not None:
      oprot.writeFieldBegin('ctrl', TType.I16, 16)
      oprot.writeI16(self.ctrl)
      oprot.writeFieldEnd()
    if self.alt is not None:
      oprot.writeFieldBegin('alt', TType.I16, 17)
      oprot.writeI16(self.alt)
      oprot.writeFieldEnd()
    if self.oskey is not None:
      oprot.writeFieldBegin('oskey', TType.I16, 18)
      oprot.writeI16(self.oskey)
      oprot.writeFieldEnd()
    if self.keymodifier is not None:
      oprot.writeFieldBegin('keymodifier', TType.I16, 19)
      oprot.writeI16(self.keymodifier)
      oprot.writeFieldEnd()
    if self.check_click is not None:
      oprot.writeFieldBegin('check_click', TType.I16, 20)
      oprot.writeI16(self.check_click)
      oprot.writeFieldEnd()
    if self.keymap_idname is not None:
      oprot.writeFieldBegin('keymap_idname', TType.STRING, 21)
      oprot.writeString(self.keymap_idname)
      oprot.writeFieldEnd()
    if self.tablet_data is not None:
      oprot.writeFieldBegin('tablet_data', TType.STRUCT, 22)
      self.tablet_data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MouseMove:
  """
  We'll use a special type for mouse moves. One the one hand we would like to
  keep all mouse movement data, but sending a message for each one results in
  too much data. Therefore we will accumulate the mouse movements and send them
  in one go once a non-mouse-movement WmEv is registered. The event->type == 4 (MOUSEMOVE)
  for mouse movements.

  Attributes:
   - timestamp
   - x
   - y
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'timestamp', None, None, ), # 1
    (2, TType.I32, 'x', None, None, ), # 2
    (3, TType.I32, 'y', None, None, ), # 3
  )

  def __init__(self, timestamp=None, x=None, y=None,):
    self.timestamp = timestamp
    self.x = x
    self.y = y

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.x = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.y = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MouseMove')
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 1)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.I32, 2)
      oprot.writeI32(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.I32, 3)
      oprot.writeI32(self.y)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WmEvMouseMoves:
  """
  Attributes:
   - moves
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'moves', (TType.STRUCT,(MouseMove, MouseMove.thrift_spec)), None, ), # 1
  )

  def __init__(self, moves=None,):
    self.moves = moves

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.moves = []
          (_etype82, _size79) = iprot.readListBegin()
          for _i83 in xrange(_size79):
            _elem84 = MouseMove()
            _elem84.read(iprot)
            self.moves.append(_elem84)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WmEvMouseMoves')
    if self.moves is not None:
      oprot.writeFieldBegin('moves', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.moves))
      for iter85 in self.moves:
        iter85.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ButPress:
  """
  For an a button press

  Note that it's hard to introspect a uiBut without including "interface_intern.h".
  I'll look into it if necessary, for now registering a button press is good enough.
  """

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ButPress')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Assignment:
  """
  Attributes:
   - pythonRepresentation
   - property
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pythonRepresentation', None, None, ), # 1
    (2, TType.STRUCT, 'property', (RNAProperty, RNAProperty.thrift_spec), None, ), # 2
  )

  def __init__(self, pythonRepresentation=None, property=None,):
    self.pythonRepresentation = pythonRepresentation
    self.property = property

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pythonRepresentation = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.property = RNAProperty()
          self.property.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Assignment')
    if self.pythonRepresentation is not None:
      oprot.writeFieldBegin('pythonRepresentation', TType.STRING, 1)
      oprot.writeString(self.pythonRepresentation)
      oprot.writeFieldEnd()
    if self.property is not None:
      oprot.writeFieldBegin('property', TType.STRUCT, 2)
      self.property.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Data:
  """
  Attributes:
   - noData
   - sessionStart
   - wmOp
   - wmEv
   - butPress
   - assignment
   - sessionEnd
   - wmEvMouseMoves
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'noData', (NoData, NoData.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'sessionStart', (SessionStart, SessionStart.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'wmOp', (WmOp, WmOp.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'wmEv', (WmEv, WmEv.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'butPress', (ButPress, ButPress.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'assignment', (Assignment, Assignment.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'sessionEnd', (SessionEnd, SessionEnd.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'wmEvMouseMoves', (WmEvMouseMoves, WmEvMouseMoves.thrift_spec), None, ), # 8
  )

  def __init__(self, noData=None, sessionStart=None, wmOp=None, wmEv=None, butPress=None, assignment=None, sessionEnd=None, wmEvMouseMoves=None,):
    self.noData = noData
    self.sessionStart = sessionStart
    self.wmOp = wmOp
    self.wmEv = wmEv
    self.butPress = butPress
    self.assignment = assignment
    self.sessionEnd = sessionEnd
    self.wmEvMouseMoves = wmEvMouseMoves

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.noData = NoData()
          self.noData.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sessionStart = SessionStart()
          self.sessionStart.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.wmOp = WmOp()
          self.wmOp.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.wmEv = WmEv()
          self.wmEv.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.butPress = ButPress()
          self.butPress.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.assignment = Assignment()
          self.assignment.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.sessionEnd = SessionEnd()
          self.sessionEnd.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.wmEvMouseMoves = WmEvMouseMoves()
          self.wmEvMouseMoves.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Data')
    if self.noData is not None:
      oprot.writeFieldBegin('noData', TType.STRUCT, 1)
      self.noData.write(oprot)
      oprot.writeFieldEnd()
    if self.sessionStart is not None:
      oprot.writeFieldBegin('sessionStart', TType.STRUCT, 2)
      self.sessionStart.write(oprot)
      oprot.writeFieldEnd()
    if self.wmOp is not None:
      oprot.writeFieldBegin('wmOp', TType.STRUCT, 3)
      self.wmOp.write(oprot)
      oprot.writeFieldEnd()
    if self.wmEv is not None:
      oprot.writeFieldBegin('wmEv', TType.STRUCT, 4)
      self.wmEv.write(oprot)
      oprot.writeFieldEnd()
    if self.butPress is not None:
      oprot.writeFieldBegin('butPress', TType.STRUCT, 5)
      self.butPress.write(oprot)
      oprot.writeFieldEnd()
    if self.assignment is not None:
      oprot.writeFieldBegin('assignment', TType.STRUCT, 6)
      self.assignment.write(oprot)
      oprot.writeFieldEnd()
    if self.sessionEnd is not None:
      oprot.writeFieldBegin('sessionEnd', TType.STRUCT, 7)
      self.sessionEnd.write(oprot)
      oprot.writeFieldEnd()
    if self.wmEvMouseMoves is not None:
      oprot.writeFieldBegin('wmEvMouseMoves', TType.STRUCT, 8)
      self.wmEvMouseMoves.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
